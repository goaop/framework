<?php

namespace Go\Aop\Framework;
use Go\Stubs\First;

/**
 * Generated by PHPUnit_SkeletonGenerator 1.2.0 on 2012-12-20 at 11:58:54.
 */
class DynamicReflectionMethodInvocationTest extends \PHPUnit_Framework_TestCase
{

    const FIRST_CLASS_NAME = First::class;

    protected static $invocationClass;

    public static function setUpBeforeClass()
    {
        parent::setUpBeforeClass();
        self::$invocationClass = MethodInvocationComposer::compose(false, false, false, false);
    }

    /**
     * Tests dynamic method invocations
     *
     * @dataProvider dynamicMethodsBatch
     */
    public function testDynamicMethodInvocation($methodName, $expectedResult)
    {
        $child      = $this->getMock(self::FIRST_CLASS_NAME, array('none'));
        $invocation = new self::$invocationClass(self::FIRST_CLASS_NAME, $methodName, []);

        $result = $invocation($child);
        $this->assertEquals($expectedResult, $result);
    }

    /**
     * Tests static method invocations with self
     *
     * @dataProvider staticSelfMethodsBatch
     */
    public function testStaticSelfMethodInvocation($methodName, $expectedResult)
    {
        $childClass = $this->getMockClass(self::FIRST_CLASS_NAME, array('none'));
        $invocation = new self::$invocationClass($childClass, $methodName, []);

        $result = $invocation($childClass);
        $this->assertEquals($expectedResult, $result);
    }

    /**
     * Tests static method invocations with self not overridden with parent
     *
     * @dataProvider staticSelfMethodsBatch
     */
    public function testStaticSelfNotOverridden($methodName, $expectedResult)
    {
        $childClass = $this->getMockClass(self::FIRST_CLASS_NAME, array($methodName));
        $invocation = new self::$invocationClass(self::FIRST_CLASS_NAME, $methodName, []);

        $result = $invocation($childClass);
        $this->assertEquals($expectedResult, $result);
    }

    /**
     * Tests static method invocations with Late Static Binding
     *
     * @dataProvider staticLsbMethodsBatch
     */
    public function testStaticLsbIsWorking($methodName)
    {
        $childClass = $this->getMockClass(self::FIRST_CLASS_NAME, array('none'));
        $invocation = new self::$invocationClass($childClass, $methodName, []);

        // LSB is not working, so it returns parent class name :( So just check that this doesn't break anything
        $result = $invocation($childClass);
        $this->markTestSkipped("Late Static Binding is not working with Reflection");
    }

    public function testValueChangedByReference()
    {
        $child      = $this->getMock(self::FIRST_CLASS_NAME, array('none'));
        $invocation = new self::$invocationClass(self::FIRST_CLASS_NAME, 'passByReference', []);

        $value  = 'test';
        $result = $invocation($child, array(&$value));
        $this->assertEquals(null, $result);
        $this->assertEquals(null, $value);
    }

    public function testRecursionWorks()
    {
        $child      = $this->getMock(self::FIRST_CLASS_NAME, array('recursion'));
        $invocation = new self::$invocationClass(self::FIRST_CLASS_NAME, 'recursion', []);

        $child->expects($this->exactly(5))->method('recursion')->will($this->returnCallback(
            function ($value, $level) use ($child, $invocation) {
                return $invocation($child, array($value, $level));
            }
        ));

        $this->assertEquals(5, $child->recursion(5,0));
        $this->assertEquals(20, $child->recursion(5,3));
    }

    public function testAdviceIsCalledForInvocation()
    {
        $child  = $this->getMock(self::FIRST_CLASS_NAME, array('none'));
        $value  = 'test';
        $advice = new BeforeInterceptor(function ($object) use (&$value) {
            $value = 'ok';
        });

        $invocation = new self::$invocationClass(self::FIRST_CLASS_NAME, 'publicMethod', array($advice));

        $result = $invocation($child, []);
        $this->assertEquals('ok', $value);
        $this->assertEquals(T_PUBLIC, $result);
    }

    public function dynamicMethodsBatch()
    {
        return array(
            array('publicMethod', T_PUBLIC),
            array('protectedMethod', T_PROTECTED),
            // array('privateMethod', T_PRIVATE), This will throw an ReflectionException, need to add use case for that
        );
    }

    public function staticSelfMethodsBatch()
    {
        return array(
            array('staticSelfPublic', T_PUBLIC),
            array('staticSelfProtected', T_PROTECTED),
            // array('staticSelfPrivate', T_PRIVATE), // This will give a Fatal Error for scope
        );
    }

    public function staticLsbMethodsBatch()
    {
        return array(
            array('staticLsbPublic'),
            array('staticLsbProtected'),
        );
    }

}
