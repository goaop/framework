<?php
declare(strict_types = 1);

namespace Go\Aop\Framework;

use Go\Stubs\First;
use Go\Stubs\FirstStatic;
use PHPUnit\Framework\TestCase;

/**
 * Generated by PHPUnit_SkeletonGenerator 1.2.0 on 2012-12-20 at 11:58:54.
 */
class StaticClosureMethodInvocationTest extends TestCase
{

    /**
     * Tests static method invocations with self
     *
     * @dataProvider staticSelfMethodsBatch
     * @param string $methodName Method to invoke
     * @param int $expectedResult Expected result
     */
    public function testStaticSelfMethodInvocation(string $methodName, int $expectedResult): void
    {
        $childClass = new First();
        $invocation = new StaticClosureMethodInvocation(get_class($childClass), $methodName, []);

        $result = $invocation($childClass);
        $this->assertEquals($expectedResult, $result);
    }

    /**
     * Tests static method invocations with self not overridden with parent
     *
     * @dataProvider staticSelfMethodsBatch
     * @param string $methodName Method to invoke
     * @param int $expectedResult Expected result
     */
    public function testStaticSelfNotOverridden($methodName, $expectedResult): void
    {
        $childClass = new First();
        $invocation = new StaticClosureMethodInvocation(First::class, $methodName, []);

        $result = $invocation($childClass);
        $this->assertEquals($expectedResult, $result);
    }

    /**
     * Tests static method invocations with Late Static Binding
     *
     * @dataProvider staticLsbMethodsBatch
     * @param string $methodName Method to invoke
     */
    public function testStaticLsbIsWorking($methodName): void
    {
        $childClass = new First();
        $invocation = new StaticClosureMethodInvocation(First::class, $methodName, []);

        $result = $invocation(get_class($childClass));
        $this->assertEquals(get_class($childClass), $result);
    }

    public function testValueChangedByReference(): void
    {
        $child      = new First();
        $invocation = new StaticClosureMethodInvocation(First::class, 'staticPassByReference', []);

        $value  = 'test';
        $result = $invocation($child, [&$value]);
        $this->assertEquals(null, $result);
        $this->assertEquals(null, $value);
    }

    public function testRecursionWorks(): void
    {
        $invocation = new StaticClosureMethodInvocation(First::class, 'staticLsbRecursion', []);
        $child      = new FirstStatic($invocation);

        /** @var First $childClass */
        $childClass = get_class($child);
        $this->assertEquals(5, $childClass::staticLsbRecursion(5,0));
        $this->assertEquals(20, $childClass::staticLsbRecursion(5,3));
    }

    public function testAdviceIsCalledForInvocation(): void
    {
        $child  = $this->createMock(First::class);
        $value  = 'test';
        $advice = new BeforeInterceptor(function () use (&$value) {
            $value = 'ok';
        });

        $invocation = new StaticClosureMethodInvocation(First::class, 'staticSelfPublic', [$advice]);

        $result = $invocation($child, []);
        $this->assertEquals('ok', $value);
        $this->assertEquals(T_PUBLIC, $result);
    }

    public function testInvocationWithDynamicArguments(): void
    {
        $child      = $this->createMock(First::class);
        $invocation = new StaticClosureMethodInvocation(First::class, 'staticVariableArgsTest', []);

        $args     = [];
        $expected = '';
        for ($i=0; $i<10; $i++) {
            $args[]   = $i;
            $expected .= $i;
            $result   = $invocation($child, $args);
            $this->assertEquals($expected, $result);
        }
    }

    public function testInvocationWithVariadicArguments(): void
    {
        $child      = $this->createMock(First::class);
        $invocation = new StaticClosureMethodInvocation(First::class, 'staticVariadicArgsTest', []);

        $args     = [];
        $expected = '';
        for ($i=0; $i<10; $i++) {
            $args[]   = $i;
            $expected .= $i;
            $result   = $invocation($child, $args);
            $this->assertEquals($expected, $result);
        }
    }

    public function staticSelfMethodsBatch(): array
    {
        return [
            ['staticSelfPublic', T_PUBLIC],
            ['staticSelfProtected', T_PROTECTED],
            ['staticSelfPublicAccessPrivate', T_PRIVATE],
        ];
    }

    public function staticLsbMethodsBatch(): array
    {
        return [
            ['staticLsbPublic'],
            ['staticLsbProtected'],
        ];
    }

}
