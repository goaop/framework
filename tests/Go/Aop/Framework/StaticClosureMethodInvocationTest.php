<?php

declare(strict_types = 1);

namespace Go\Aop\Framework;

use Go\Stubs\First;
use Go\Stubs\FirstStatic;
use PHPUnit\Framework\TestCase;

/**
 * Generated by PHPUnit_SkeletonGenerator 1.2.0 on 2012-12-20 at 11:58:54.
 */
class StaticClosureMethodInvocationTest extends TestCase
{
    /**
     * Tests static method invocations with self
     *
     * @param string $methodName Method to invoke
     * @param int $expectedResult Expected result
     */
    #[\PHPUnit\Framework\Attributes\DataProvider('staticSelfMethodsBatch')]
    public function testStaticSelfMethodInvocation(string $methodName, int $expectedResult): void
    {
        $invocation = new StaticClosureMethodInvocation([],First::class, $methodName);
        $result     = $invocation(First::class);
        $this->assertEquals($expectedResult, $result);
    }

    /**
     * Tests static method invocations with Late Static Binding
     *
     * @param string $methodName Method to invoke
     */
    #[\PHPUnit\Framework\Attributes\DataProvider('staticLsbMethodsBatch')]
    public function testStaticLsbIsWorking($methodName): void
    {
        $invocation = new StaticClosureMethodInvocation([], First::class, $methodName);
        $result     = $invocation(First::class);
        $this->assertEquals(First::class, $result);
    }

    public function testValueChangedByReference(): void
    {
        $invocation = new StaticClosureMethodInvocation([], First::class, 'staticPassByReference');

        $value  = 'test';
        $result = $invocation(First::class, [&$value]);
        $this->assertEquals(null, $result);
        $this->assertEquals(null, $value);
    }

    public function testRecursionWorks(): void
    {
        $invocation = new StaticClosureMethodInvocation([],First::class, 'staticLsbRecursion');
        FirstStatic::init($invocation);

        $this->assertEquals(5, FirstStatic::staticLsbRecursion(5,0));
        $this->assertEquals(20, FirstStatic::staticLsbRecursion(5,3));
    }

    public function testAdviceIsCalledForInvocation(): void
    {
        $value  = 'test';
        $advice = new BeforeInterceptor(function () use (&$value) {
            $value = 'ok';
        });

        $invocation = new StaticClosureMethodInvocation([$advice], First::class, 'staticSelfPublic');

        $result = $invocation(First::class, []);
        $this->assertEquals('ok', $value);
        $this->assertEquals(T_PUBLIC, $result);
    }

    public function testInvocationWithDynamicArguments(): void
    {
        $invocation = new StaticClosureMethodInvocation([], First::class, 'staticVariableArgsTest');

        $args     = [];
        $expected = '';
        for ($i=0; $i<10; $i++) {
            $args[]   = $i;
            $expected .= $i;
            $result   = $invocation(First::class, $args);
            $this->assertEquals($expected, $result);
        }
    }

    public function testInvocationWithVariadicArguments(): void
    {
        $invocation = new StaticClosureMethodInvocation([], First::class, 'staticVariadicArgsTest');

        $args     = [];
        $expected = '';
        for ($i=0; $i<10; $i++) {
            $args[]   = $i;
            $expected .= $i;
            $result   = $invocation(First::class, $args);
            $this->assertEquals($expected, $result);
        }
    }

    public static function staticSelfMethodsBatch(): array
    {
        return [
            ['staticSelfPublic', T_PUBLIC],
            ['staticSelfProtected', T_PROTECTED],
            ['staticSelfPublicAccessPrivate', T_PRIVATE],
        ];
    }

    public static function staticLsbMethodsBatch(): array
    {
        return [
            ['staticLsbPublic'],
            ['staticLsbProtected'],
        ];
    }

}
